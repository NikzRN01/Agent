"""
shopping_budget_agent.py

Shopping & Budget Agent for Meal Planner Project.

Responsibilities:
1. Take a weekly Menu (output of RecipeAgent) with ingredients.
2. Aggregate ingredients across days/meals.
3. Look up or approximate prices per store (mock implementation for now).
4. Build a consolidated grocery list with best store choice per item.
5. Compare estimated total cost against user budget.
6. Suggest high-impact cost-saving changes if over budget.
"""

from __future__ import annotations
from dataclasses import dataclass, asdict
from math import ceil
from typing import List, Dict, Tuple, Any


# =========================
#   DATA STRUCTURES
# =========================

@dataclass
class Ingredient:
    name: str
    quantity: float
    unit: str


@dataclass
class Meal:
    type: str               # e.g. "breakfast", "lunch", "dinner"
    name: str
    servings: int
    ingredients: List[Ingredient]


@dataclass
class DayPlan:
    day: int                # 1..7
    meals: List[Meal]


@dataclass
class Menu:
    """Weekly menu â€“ should match your RecipeAgent output structure."""
    days: List[DayPlan]


# =========================
#   SHOPPING & BUDGET AGENT
# =========================

class ShoppingBudgetAgent:
    """
    Shopping & Budget Agent

    Usage:
        agent = ShoppingBudgetAgent(currency="INR")
        result = agent.build_shopping_plan(menu, stores=["Amazon", "Flipkart"], budget=2000)

    Result (dict) includes:
        - shopping_list: consolidated list of items with prices
        - estimated_total_cost
        - currency
        - budget
        - within_budget
        - amount_over_budget
        - recipe_change_suggestions
    """

    def __init__(self, currency: str = "INR") -> None:
        self.currency = currency

    # ---------- PUBLIC ENTRY POINT ----------

    def build_shopping_plan(
        self,
        menu: Menu,
        stores: List[str],
        budget: float,
    ) -> Dict[str, Any]:
        """
        Main method called by the orchestrator.

        Parameters
        ----------
        menu : Menu
            Weekly menu generated by RecipeAgent.
        stores : List[str]
            Stores to consider for pricing (e.g., ["Amazon", "Flipkart"]).
        budget : float
            User's weekly grocery budget.

        Returns
        -------
        Dict[str, Any]
            {
              "shopping_list": [...],
              "estimated_total_cost": float,
              "currency": str,
              "budget": float,
              "within_budget": bool,
              "amount_over_budget": float,
              "recipe_change_suggestions": [...]
            }
        """
        # 1) Aggregate ingredients across all days/meals
        aggregate = self._aggregate_ingredients(menu)

        # 2) Create shopping list with best store options and total cost
        shopping_list, total_cost = self._build_shopping_list_with_prices(
            aggregate=aggregate,
            stores=stores,
        )

        # 3) Evaluate cost vs budget + suggestions
        budget_info = self._evaluate_budget(
            shopping_list=shopping_list,
            total_cost=total_cost,
            budget=budget,
        )

        return {
            "shopping_list": shopping_list,
            "estimated_total_cost": total_cost,
            "currency": self.currency,
            "budget": budget,
            "within_budget": budget_info["within_budget"],
            "amount_over_budget": budget_info["amount_over_budget"],
            "recipe_change_suggestions": budget_info["recipe_change_suggestions"],
        }

    # ---------- SHOPPING LOGIC ----------

    def _aggregate_ingredients(self, menu: Menu) -> Dict[Tuple[str, str], float]:
        """
        Combine all ingredients across the menu.

        Returns
        -------
        Dict[(ingredient_name_lower, unit), total_quantity]
        """
        aggregate: Dict[Tuple[str, str], float] = {}

        for day in menu.days:
            for meal in day.meals:
                for ing in meal.ingredients:
                    key = (ing.name.strip().lower(), ing.unit)
                    aggregate[key] = aggregate.get(key, 0.0) + ing.quantity

        return aggregate

    def _mock_price_lookup(
        self,
        item_name: str,
        unit: str,
        stores: List[str],
    ) -> List[Dict[str, Any]]:
        """
        PRICE LOOKUP LAYER (mock).

        Replace this with:
        - Amazon / Flipkart APIs, or
        - A local CSV/database of prices.

        Returns
        -------
        List of store options:
        [
          { "store": "...", "package_size": 1000, "package_unit": "gram", "price": 120 },
          ...
        ]
        """
        name = item_name.lower()

        # Example specific prices
        if name == "oats":
            return [
                {"store": "Amazon", "package_size": 1000, "package_unit": "gram", "price": 120},
                {"store": "Flipkart", "package_size": 1000, "package_unit": "gram", "price": 135},
            ]
        if name == "paneer":
            return [
                {"store": "LocalDairy", "package_size": 200, "package_unit": "gram", "price": 230},
            ]
        if name in ["rice", "wheat flour", "wheatflour"]:
            return [
                {"store": "LocalStore", "package_size": 1000, "package_unit": "gram", "price": 70},
            ]

        # Default fallback prices
        return [
            {
                "store": stores[0] if stores else "DefaultStore",
                "package_size": 1000,
                "package_unit": unit,
                "price": 100,
            }
        ]

    def _build_shopping_list_with_prices(
        self,
        aggregate: Dict[Tuple[str, str], float],
        stores: List[str],
    ) -> (List[Dict[str, Any]], float):
        """
        For each ingredient, choose cheapest store option and compute total cost.

        Returns
        -------
        shopping_list : List[Dict[str, Any]]
        total_cost    : float
        """
        shopping_list: List[Dict[str, Any]] = []
        total_cost = 0.0

        for (name, unit), qty in aggregate.items():
            options_raw = self._mock_price_lookup(name, unit, stores)

            store_options = []
            best_cost = None
            best_option = None

            for opt in options_raw:
                packages_needed = ceil(qty / opt["package_size"])
                effective_cost = packages_needed * opt["price"]

                store_options.append(
                    {
                        "store": opt["store"],
                        "package_size": opt["package_size"],
                        "package_unit": opt["package_unit"],
                        "price": opt["price"],
                        "currency": self.currency,
                    }
                )

                if best_cost is None or effective_cost < best_cost:
                    best_cost = effective_cost
                    best_option = {
                        "chosen_store": opt["store"],
                        "packages_needed": packages_needed,
                        "chosen_price": opt["price"],
                        "effective_cost": effective_cost,
                    }

            total_cost += best_cost or 0.0

            shopping_list.append(
                {
                    "item": name,
                    "category": "other",  # you can later classify as grains/dairy/etc.
                    "required_quantity": qty,
                    "unit": unit,
                    "store_options": store_options,
                    **best_option,
                }
            )

        return shopping_list, total_cost

    # ---------- BUDGET LOGIC ----------

    def _evaluate_budget(
        self,
        shopping_list: List[Dict[str, Any]],
        total_cost: float,
        budget: float,
    ) -> Dict[str, Any]:
        """
        Compare total_cost vs budget and generate high-level cost-saving suggestions.
        """
        within_budget = total_cost <= budget
        amount_over_budget = max(0.0, total_cost - budget)

        recipe_change_suggestions: List[Dict[str, Any]] = []

        if not within_budget:
            # Simple heuristic:
            # Find expensive "luxury" ingredients and suggest reducing them.
            luxury_keywords = ["paneer", "cheese", "nut", "almond", "cashew", "quinoa"]

            luxury_items = [
                item
                for item in shopping_list
                if any(kw in item["item"].lower() for kw in luxury_keywords)
            ]

            # Sort by descending effective cost
            luxury_items.sort(key=lambda x: x["effective_cost"], reverse=True)

            for item in luxury_items[:3]:
                recipe_change_suggestions.append(
                    {
                        "impact": "medium",
                        "description": (
                            f"Reduce or replace '{item['item']}' in some meals "
                            f"(e.g., use lentils/vegetables instead) to cut costs."
                        ),
                        "estimated_savings": round(0.3 * item["effective_cost"], 2),
                    }
                )

        return {
            "within_budget": within_budget,
            "amount_over_budget": amount_over_budget,
            "recipe_change_suggestions": recipe_change_suggestions,
        }


# =========================
#   SIMPLE DEMO / TEST
# =========================

if __name__ == "__main__":
    # Minimal example to test the agent independently.

    # Build a tiny fake menu similar to what RecipeAgent would output
    breakfast = Meal(
        type="breakfast",
        name="Masala Oats",
        servings=2,
        ingredients=[
            Ingredient(name="Oats", quantity=50, unit="gram"),
            Ingredient(name="Onion", quantity=0.5, unit="piece"),
        ],
    )

    dinner = Meal(
        type="dinner",
        name="Paneer Curry",
        servings=2,
        ingredients=[
            Ingredient(name="Paneer", quantity=80, unit="gram"),
            Ingredient(name="Tomato", quantity=0.5, unit="piece"),
        ],
    )

    menu = Menu(
        days=[
            DayPlan(day=1, meals=[breakfast, dinner]),
            DayPlan(day=2, meals=[breakfast, dinner]),
        ]
    )

    agent = ShoppingBudgetAgent(currency="INR")

    result = agent.build_shopping_plan(
        menu=menu,
        stores=["Amazon", "Flipkart"],
        budget=500,  # weekly budget
    )

    # Pretty-print result
    from pprint import pprint
    pprint(result)
